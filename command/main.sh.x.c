#if 0
	shc Version 4.0.1, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f command/main.sh -o tak 
#endif

static  char data [] = 
#define      xecc_z	15
#define      xecc	((&data[1]))
	"\205\313\032\377\002\057\021\113\174\340\003\111\342\004\116\322"
	"\266\144\223"
#define      chk2_z	19
#define      chk2	((&data[21]))
	"\031\207\325\312\100\316\170\225\346\117\213\262\133\213\244\135"
	"\251\065\273\353\061"
#define      inlo_z	3
#define      inlo	((&data[40]))
	"\234\001\235"
#define      lsto_z	1
#define      lsto	((&data[43]))
	"\367"
#define      date_z	1
#define      date	((&data[44]))
	"\057"
#define      tst1_z	22
#define      tst1	((&data[50]))
	"\354\216\025\110\166\014\255\133\017\353\304\022\351\254\100\052"
	"\215\362\251\005\152\121\156\113\123\253\031"
#define      shll_z	10
#define      shll	((&data[73]))
	"\246\027\203\207\107\237\073\075\065\051\345\225"
#define      tst2_z	19
#define      tst2	((&data[87]))
	"\031\352\070\134\223\176\311\141\173\030\213\161\320\321\205\377"
	"\303\250\263\007\274\276\015\147\235"
#define      chk1_z	22
#define      chk1	((&data[111]))
	"\070\037\060\351\204\075\022\111\065\304\372\235\367\224\326\116"
	"\351\012\225\160\032\375\113\156"
#define      pswd_z	256
#define      pswd	((&data[177]))
	"\271\123\167\271\340\251\174\311\046\102\344\303\105\072\252\326"
	"\165\027\245\215\256\042\026\031\025\217\325\314\326\257\354\137"
	"\256\212\377\236\146\041\211\102\033\360\042\005\212\043\224\134"
	"\210\353\011\322\056\322\102\340\072\051\242\213\301\327\171\363"
	"\230\121\220\217\226\342\374\120\331\015\107\173\165\376\345\242"
	"\045\010\303\372\210\144\162\032\221\260\310\173\222\223\254\313"
	"\115\340\022\114\305\103\055\070\253\056\352\035\031\201\076\313"
	"\130\212\333\150\264\031\373\026\044\237\003\133\136\222\070\341"
	"\006\061\312\155\144\120\362\073\301\261\271\013\242\232\177\135"
	"\153\307\064\265\236\344\124\336\137\263\046\233\111\132\271\066"
	"\270\202\071\036\320\360\225\250\146\063\101\160\145\042\361\062"
	"\376\161\317\250\205\274\041\356\336\130\320\016\251\266\063\172"
	"\121\071\170\364\335\347\031\201\127\114\216\364\271\163\351\204"
	"\222\305\123\112\244\123\341\124\125\076\324\103\320\024\007\350"
	"\011\312\170\306\224\142\077\317\062\146\067\056\012\143\223\002"
	"\031\175\144\356\354\354\216\336\103\335\044\103\047\114\373\126"
	"\263\200\273\362\037\146\130\236\275\373\134\062\301\300\326\171"
	"\256\253\045\227\377\360\072\002\065\137\250\265\323\227\056\346"
	"\073\064\151\355\101\147\203\315\325\312\240\357\270\217\346\255"
	"\275\365\135\001\162\125\170\013\330\002\153"
#define      rlax_z	1
#define      rlax	((&data[448]))
	"\272"
#define      msg1_z	65
#define      msg1	((&data[464]))
	"\257\274\117\374\312\352\302\160\200\316\274\364\056\134\100\270"
	"\032\146\166\010\271\335\270\351\323\135\207\205\245\141\130\364"
	"\247\315\323\250\102\226\122\001\231\270\052\122\313\127\256\233"
	"\132\351\147\156\125\253\356\143\312\306\276\344\053\205\247\132"
	"\077\322\236\340\312\343\220\112\051\100\373\100\225\231\131\225"
	"\334\053\242\256\336\021\110\124\151\301\323\152\327"
#define      msg2_z	19
#define      msg2	((&data[544]))
	"\044\027\201\213\163\060\277\365\216\066\341\142\310\105\135\307"
	"\144\340\037\021\257\200\246"
#define      opts_z	1
#define      opts	((&data[565]))
	"\220"
#define      text_z	1510
#define      text	((&data[939]))
	"\046\234\027\251\352\363\047\340\002\110\045\001\352\131\354\353"
	"\156\356\003\221\106\132\312\070\224\377\022\230\346\072\057\033"
	"\325\275\120\240\335\114\072\111\204\253\311\017\236\176\044\007"
	"\064\162\121\065\005\076\266\300\202\247\366\060\301\133\065\137"
	"\206\112\141\241\231\213\032\155\301\134\174\002\035\367\234\000"
	"\200\140\045\355\335\142\022\232\266\367\376\346\177\147\034\017"
	"\343\152\203\221\106\071\334\275\061\061\237\042\071\341\334\122"
	"\321\110\356\372\243\001\124\343\376\306\357\325\372\046\215\010"
	"\312\065\204\362\211\326\354\010\277\025\277\170\005\346\054\041"
	"\330\135\373\235\124\330\150\064\342\256\303\244\135\115\163\052"
	"\317\226\351\261\103\007\376\323\144\070\075\170\316\236\231\135"
	"\070\144\274\224\020\143\163\056\214\114\033\033\141\321\155\027"
	"\375\146\125\063\127\070\116\230\303\227\347\054\312\145\256\244"
	"\320\220\073\316\332\362\324\357\366\344\206\145\111\236\232\102"
	"\336\061\100\117\264\242\250\336\265\130\075\205\234\224\144\203"
	"\104\210\333\052\040\243\120\341\231\363\102\037\300\230\365\353"
	"\070\273\254\056\333\254\160\275\174\303\234\337\125\251\064\276"
	"\064\051\001\054\227\204\043\001\326\015\027\022\304\000\044\151"
	"\115\355\044\127\240\374\006\340\215\177\320\374\206\267\274\176"
	"\114\345\251\320\112\010\144\325\241\375\211\001\034\357\015\260"
	"\123\167\321\071\241\231\135\175\176\307\301\043\061\166\375\310"
	"\205\105\145\137\316\163\152\004\361\273\245\255\053\153\073\051"
	"\257\365\225\217\161\310\050\367\310\130\313\242\033\164\104\341"
	"\106\021\344\322\253\053\005\255\174\232\007\213\314\014\047\201"
	"\050\006\044\104\362\154\263\103\002\207\146\077\037\106\033\340"
	"\165\272\203\222\031\141\171\206\204\213\240\125\371\160\376\002"
	"\235\076\015\002\131\266\114\162\145\333\305\062\263\177\142\354"
	"\205\070\224\070\153\065\267\362\105\176\054\275\214\241\065\340"
	"\232\263\162\022\075\151\340\117\235\337\127\131\375\344\237\316"
	"\242\157\350\001\003\077\076\103\235\260\050\341\037\311\073\370"
	"\366\031\105\373\077\164\016\304\365\063\126\153\203\252\042\076"
	"\254\040\245\067\020\201\011\024\373\071\332\176\226\243\024\204"
	"\323\304\120\311\363\263\006\253\134\356\102\322\251\320\237\031"
	"\040\077\157\133\146\277\176\044\317\355\120\040\166\224\247\127"
	"\233\130\342\011\253\255\255\215\013\044\235\026\101\042\035\010"
	"\031\305\264\364\022\070\104\322\363\056\156\132\142\171\373\231"
	"\104\310\277\326\365\336\105\131\225\144\126\326\262\041\347\146"
	"\013\114\144\125\162\261\077\350\266\374\004\106\161\120\234\072"
	"\057\336\367\046\023\170\131\011\326\122\345\037\176\120\261\315"
	"\162\220\211\023\173\162\111\166\236\074\302\074\232\243\223\214"
	"\216\072\037\206\154\266\242\210\366\355\337\364\176\363\027\347"
	"\365\272\154\375\017\234\133\110\333\350\166\340\127\327\217\065"
	"\105\115\306\306\056\304\131\024\036\173\300\131\011\272\236\253"
	"\240\135\362\154\134\306\141\064\232\204\161\005\360\330\072\343"
	"\254\311\112\276\323\314\166\064\350\173\234\245\225\137\177\235"
	"\021\161\102\366\167\037\263\003\151\362\333\207\147\071\326\070"
	"\155\216\127\326\006\104\261\026\005\245\160\136\140\206\314\022"
	"\043\260\256\047\130\330\070\177\210\252\236\031\320\271\170\067"
	"\301\275\070\146\107\126\130\144\023\241\167\051\350\207\043\110"
	"\130\332\107\334\066\134\135\031\213\356\322\331\264\036\124\360"
	"\104\351\043\017\360\144\134\126\073\155\036\047\237\125\205\136"
	"\065\211\042\017\313\241\060\243\227\222\177\021\264\304\231\123"
	"\076\255\354\072\243\153\214\004\271\174\207\063\347\250\131\114"
	"\074\277\332\136\271\074\005\010\246\145\105\310\365\223\354\276"
	"\115\017\005\236\111\043\261\145\165\224\355\204\126\264\045\144"
	"\251\046\144\273\221\142\070\221\153\076\116\242\010\153\337\317"
	"\317\074\033\267\173\032\051\247\152\104\257\227\037\265\071\364"
	"\351\320\373\315\342\214\063\357\022\112\230\147\204\030\022\322"
	"\145\227\270\072\214\311\302\352\214\036\365\164\255\261\316\131"
	"\223\225\156\144\024\066\156\357\035\063\105\033\120\126\010\113"
	"\112\316\256\341\376\046\243\027\062\076\012\201\177\350\176\077"
	"\162\211\266\022\356\255\032\074\341\321\103\053\345\366\211\227"
	"\300\247\277\140\203\125\207\156\223\351\044\375\044\232\250\226"
	"\152\356\071\376\006\314\233\305\047\147\117\016\022\057\115\140"
	"\215\324\234\364\205\273\225\031\266\114\375\262\131\136\236\152"
	"\217\052\212\176\275\325\366\130\325\111\272\125\004\262\306\337"
	"\050\217\005\035\130\016\152\073\245\053\054\255\056\161\236\324"
	"\024\350\070\266\114\153\123\132\066\171\075\323\303\225\220\223"
	"\245\052\112\231\005\246\373\176\345\107\330\047\043\255\110\172"
	"\155\145\052\356\257\102\363\204\226\245\044\050\176\203\045\301"
	"\355\164\335\332\174\071\206\235\311\304\354\227\305\152\235\154"
	"\027\265\377\131\245\230\011\072\344\117\110\025\035\066\126\076"
	"\157\234\004\301\260\117\314\031\147\032\211\027\377\052\104\110"
	"\207\254\205\060\164\056\073\171\015\100\250\304\375\013\155\161"
	"\063\177\243\171\301\173\044\377\205\011\376\136\016\166\127\260"
	"\353\370\026\205\156\051\046\206\014\063\204\301\103\220\063\137"
	"\010\217\326\210\352\114\263\040\167\203\243\012\372\331\213\004"
	"\242\206\236\204\177\305\146\330\300\050\365\152\350\366\217\106"
	"\170\264\366\352\214\242\332\017\324\010\226\363\016\134\053\254"
	"\202\236\207\342\301\307\246\031\254\177\331\377\112\055\222\127"
	"\355\302\346\044\200\100\176\311\007\060\135\070\367\060\156\324"
	"\071\156\050\354\213\047\363\264\365\337\145\135\131\177\377\366"
	"\173\146\245\204\235\203\256\336\216\202\175\130\131\174\054\155"
	"\263\174\316\271\137\233\123\161\020\330\064\062\326\121\106\102"
	"\243\007\143\022\354\346\223\375\171\057\071\124\100\355\275\324"
	"\013\242\153\252\156\037\231\341\350\031\352\045\272\171\036\374"
	"\353\057\120\272\172\022\177\314\106\311\267\105\167\005\220\347"
	"\031\331\121\125\211\155\311\135\346\117\342\345\060\167\363\240"
	"\133\202\264\223\325\304\255\355\243\136\100\204\365\011\177\335"
	"\241\314\231\141\351\147\016\245\317\276\151\357\337\356\175\212"
	"\152\126\051\133\171\145\366\244\333\337\306\051\263\130\042\176"
	"\214\120\373\175\332\316\022\353\313\360\162\045\117\256\047\061"
	"\362\244\315\315\313\076\123\317\027\057\042\112\232\324\255\245"
	"\250\367\152\326\306\370\003\064\313\171\013\007\010\134\311\203"
	"\260\062\023\227\360\252\152\013\026\101\326\107\033\016\123\375"
	"\311\044\376\200\314\331\067\310\223\005\142\141\156\324\175\160"
	"\016\064\050\303\134\057\047\225\231\055\073\221\025\372\170\105"
	"\166\132\052\313\207\166\253\340\154\260\141\106\333\025\327\121"
	"\213\102\232\070\354\220\170\175\254\334\336\041\030\002\063\134"
	"\242\011\235\311\235\236\104\323\153\351\252\326\013\355\171\102"
	"\117\020\254\120\106\035\361\154\356\355\071\170\043\135\372\271"
	"\155\020\217\314\103\120\101\121\037\002\060\265\213\163\200\031"
	"\274\136\363\251\114\012\173\152\235\076\065\174\153\066\230\344"
	"\007\031\161\057\237\065\325\367\245\250\275\300\034\357\163\315"
	"\040\305\000\274\220\060\301\144\204\037\317\310\261\116\242\101"
	"\203\141\142\373\246\135\012\061\141\260\157\207\355\074\240\241"
	"\111\006\027\350\126\330\352\370\341\317\173\053\056\234\337\315"
	"\274\126\047\363\214\135\064\106\172\362\343\220\136\241\266\111"
	"\162\362\003\247\027\246\333\026\262\373\252\140\373\175\241\364"
	"\061\331\202\164\224\066\363\214\031\071\244\103\332\355\257\175"
	"\130\374\356\340\174\114\065\367\060\267\270\372\347\361\260\161"
	"\136\377\331\113\007\320\014\025\261\154\346\131\002\145\144\115"
	"\164\072\233\365\347\341\002\357\134\355\104\306\106\305\307\326"
	"\230\207\174\002\263\061\333\262\167\135\224\010\364\272\361\264"
	"\306\107\260\316\320\221\172\335\060\350\362\204\104\160\115\014"
	"\163\155\207\326\205\260\011\133\342\056\167\052\373\073\034\014"
	"\035\300\321\371\311\356\377\121\131\177\107\360\060\305\013\233"
	"\174\220\302\143\272\005\077\301\271\000\336\101\246\060\125\155"
	"\325\271\353\174\072\277\335\377\017\323\351\057\312\135\211\037"
	"\170\202\216\351\041\177\277\127\320\170\153\101\205\171\036\272"
	"\124\326\112\056\273\130\103\015\216\340\333\245\316\156\274\155"
	"\255\364\271\023\224\113\157\161\363\375\113\123\361\020\141\043"
	"\244\072\002\313\324\256\374\210\326\227\070\003\332\040\245\367"
	"\234\113\123\143\003\066\124\032\105\146\316\102\125\075\075\167"
	"\044\107\066\214\156\033\255\030\207\236\135\153\330\253\334\370"
	"\110\365\016\042\215\166\164\076\007\235\121\210\071\274\037\066"
	"\070\117\131\317\153\240\141\136\206\031\126\200\324\370\016\347"
	"\236\023\077\146\004\035\134\117\114\375\016\044\140\165\007\064"
	"\036\332\332\262\213\246\005\367\261\277\274\061\173\364\112\373"
	"\063\247\264\127"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define HARDENINGSP	0	/* Define as 1 to disable bash child process */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;

    int lentmp = len;

#if HARDENINGSP
    //Start tracing to protect from dump & trace
    if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }

    //Decode Bash
    while (len > 0) {
        indx++;
        tmp = stte[indx];
        jndx += tmp;
        stte[indx] = stte[jndx];
        stte[jndx] = tmp;
        tmp += stte[indx];
        *ptr ^= stte[tmp];
        ptr++;
        len--;
    }

    //Exec bash script
    system(tmp2);

    //Empty script variable
    memcpy(tmp2, str, lentmp);

    //Sinal to detach ptrace
    ptrace(PTRACE_DETACH, 0, 0, 0);
    exit(0);

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
#endif /* HARDENINGSP Exit here anyway*/

    int pid, status;
    pid = fork();

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            printf("Operation not permitted\n");
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Exec bash script
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {
        wait(&status);
    }

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
} 
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
